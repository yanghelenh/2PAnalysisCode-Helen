% heatmapMoveCondData.m
%
% Function to generate heat map of movement conditioned data generated by
%  moveCondPairData(). Similar to scatterMoveCondData() but as heat map,
%  plots the value of the dependent variable z against two independent
%  variables, x and y. Each value in heatmap is a mean of the values that
%  contributed to it.
% Specify x, y, and z data by field name. Can run any combination of
%  fictrac and imaging data, though some aren't very meaningful.
% Plots either multiple flies on the same heatmap or individual flies each
%  as own figure.
% Plots either only data during moving bouts or all data.
% Can specify temporal offset between z data and x,y data. 
% Specify number of bins as well as min and max values for all variables.
%
% INPUTS:
%   condPairData - array of structs, output of moveCondPairData()
%   xDataName - string specifying name of data to put on x-axis;
%       independent variable 1
%   yDataName - string specifying name of data to put on y-axis;
%       independent variable 2
%   zDataName - string specifying name of data to represent as color on
%       heat map; dependent variable
%   xScale - 3 element vector of [xmin, xmax, xNumBins]
%   yScale - 3 element vector of [ymin, ymax, yNumBins]
%   zScale - z axis limits, as 2 element vector
%   minNumVals - minimum number of values that need to be in a bin for it
%       to be plotted in heat map
%   offset - offset between zData and x/y Data, positive values are zData
%       before x/yData, negative values are zData before x/yData; in units
%       of samples
%   samePlot - binary for whether to put all flies on same plot (1) or to
%       generate a separate figure for each fly (0)
%   plotNotMove - binary for whether to plot not moving data points; (1)
%       for yes, (0) for no; if yes, plot as x (moving points are circles)
%   degPerMM - if not empty, will convert any fictrac variables using mm to
%       deg, using this conversion factor
%   ttl - plot title
%
% OUTPUTS:
%   f - handle to figure(s)
%
% CREATED: 9/13/19 - HHY
%
% UPDATED: 9/19/19 - HHY
%

function [f, heatmapMat, countsMat] = heatmapMoveCondData(condPairData,...
    xDataName, yDataName, zDataName, xScale, yScale, zScale, minNumVals,...
    offset, samePlot, plotNotMove, degPerMM, ttl)

    colorRes = 256; % number of different colors in heatmap, must be even
    colorbarWhite = 0; % using redblue colorbar, what value is white
    nanVal = [0.5 0.5 0.5]; % value for bins without enough data
    numTicks = 11; % number of ticks for colorbar
    
    % fictrac behavioral variables
    behVars = {'fwdVel', 'slideVel', 'yawAngVel', 'yawAngSpd', ...
        'totAngSpd'};
    % imaging variables
    imgVars = {'left', 'right', 'sum', 'diff'};
    
    % number of flies
    numFlies = length(condPairData);
    
    % preallocate matrix that will become heat map, dimension 3 is number
    %  of flies, rows = y, col = x
    heatmapMat = zeros(yScale(3), xScale(3), numFlies);
    % preallocate matrix that counts number of samples that go into each
    %  bin
    countsMat = zeros(size(heatmapMat));
    
    % (xmax-xmin)/xNumBins
    xBinWidth = (xScale(2) - xScale(1)) / xScale(3);
    % start values of x bins
    xBinStarts = xScale(1):xBinWidth:(xScale(2) - xBinWidth);
    % end values of x bins
    xBinEnds = (xScale(1) + xBinWidth):xBinWidth:xScale(2);
    % midpoints of x bins (for plotting)
    xBinMids = (xBinStarts + xBinEnds) / 2;
    
    % same for y bins
    yBinWidth = (yScale(2) - yScale(1)) / yScale(3);
    yBinStarts = yScale(1):yBinWidth:(yScale(2) - yBinWidth);
    yBinEnds = (yScale(1) + yBinWidth):yBinWidth:yScale(2);
    yBinMids = (yBinStarts + yBinEnds) / 2;
    
    % loop through all flies
    for i = 1:numFlies
        % get x data, assumes xDataName is field of img or fictrac
        if (any(strcmpi(imgVars, xDataName)))
            xDat = condPairData(i).img.(xDataName);
            xDat(condPairData(i).moveLog) = nan;
            % not moving data
            xDatNM = condPairData(i).img.(xDataName);
            xDatNM(condPairData(i).notMoveLog) = nan;
            xUnits = 'dF/F';
        else
            xDat = condPairData(i).fictrac.move.(xDataName);
            xDatNM = condPairData(i).fictrac.notMove.(xDataName);
            % if the x data is in mm and the user desires a conversion
            %  to degrees
            if ~isempty(degPerMM) && ...
                    any(strcmpi(behVars(1:2), xDataName))
                xDat = xDat .* degPerMM;
                xDatNM = xDatNM .* degPerMM;
                xUnits = 'deg/s';
            elseif any(strcmpi(behVars(3:end), xDataName))
                xUnits = 'deg/s';
            else
                xUnits = 'mm/s';
            end
        end
        % get y data, assumes yDataName is field of img or fictrac
        if (any(strcmpi(imgVars, yDataName)))
            yDat = condPairData(i).img.(yDataName);
            yDat(condPariData(i).moveLog) = nan;
            % not moving data
            yDatNM = condPairData(i).img.(yDataName);
            yDatNM(condPairData(i).notMoveLog) = nan;
            yUnits = 'dF/F';
        else
            yDat = condPairData(i).fictrac.move.(yDataName);
            yDatNM = condPairData(i).fictrac.notMove.(yDataName);
            % if the y data is in mm and the user desires a conversion
            %  to degrees
            if ~isempty(degPerMM) && ...
                    any(strcmpi(behVars(1:2), yDataName))
                yDat = yDat .* degPerMM;
                yDatNM = yDatNM .* degPerMM;
                yUnits = 'deg/s';
            elseif any(strcmpi(behVars(3:end), yDataName))
                yUnits = 'deg/s';
            else
                yUnits = 'mm/s';
            end
        end
        % get z data, assumes zDataName is field of img or fictrac
        if (any(strcmpi(imgVars, zDataName)))
            zDat = condPairData(i).img.(zDataName);
            zDat(condPairData(i).moveLog) = nan;
            % not moving data
            zDatNM = condPairData(i).img.(zDataName);
            zDatNM(condPairData(i).notMoveLog) = nan;
            zUnits = 'dF/F';
        else
            zDat = condPairData(i).fictrac.move.(zDataName);
            zDatNM = condPairData(i).fictrac.notMove.(zDataName);
            % if the z data is in mm and the user desires a conversion
            %  to degrees
            if ~isempty(degPerMM) && ...
                    any(strcmpi(behVars(1:2), zDataName))
                zDat = zDat .* degPerMM;
                zDatNM = zDatNM .* degPerMM;
                zUnits = 'deg/s';
            elseif any(strcmpi(behVars(3:end), zDataName))
                zUnits = 'deg/s';
            else
                zUnits = 'mm/s';
            end
        end
        
        % introduce offset to data
        xDat = circshift(xDat, offset);
        yDat = circshift(yDat, offset);
        if (plotNotMove)
            xDatNM = circshift(xDatNM, offset);
            yDatNM = circshift(yDatNM, offset);
        end
        % delete appropriate number of elements from xDat, yDat, zDat, so
        %  wrapped elements aren't used
        if (offset < 0) % negative offsets, remove from end
            xDat = xDat(1:(end + offset));
            yDat = yDat(1:(end + offset));
            zDat = zDat(1:(end + offset));
            if (plotNotMove)
                xDatNM = xDatNM(1:(end + offset));
                yDatNM = yDatNM(1:(end + offset));
                zDatNM = zDatNM(1:(end + offset));
            end
        elseif (offset > 0) % positive offsets, remove from front
            xDat = xDat((offset + 1):end);
            yDat = yDat((offset + 1):end);
            zDat = zDat((offset + 1):end);
            if (plotNotMove)
                xDatNM = xDatNM((offset + 1):end);
                yDatNM = yDatNM((offset + 1):end);
                zDatNM = zDatNM((offset + 1):end);
            end
        end
        
        % loop through all data points, put each one in appropriate bin
        for j = 1:length(xDat)
            % point has all valid values (not NaN)
            if (~isnan(xDat(j)) && ~isnan(yDat(j)) && ~isnan(zDat(j)))
                % find index of bin, going from both directions of start
                %  and end of bin
                whichXBinStart = find(xDat(j) >= xBinStarts, 1, 'last');
                whichXBinEnd = find(xDat(j) < xBinEnds, 1, 'first');
            
                % if either is empty, xDat point exceeds x limits
                if (~isempty(whichXBinStart) && ~isempty(whichXBinEnd))
                    whichXBin = whichXBinStart;
                else
                    whichXBin = [];
                end
                
                % find index of bin, going from both directions of start
                %  and end of bin
                whichYBinStart = find(yDat(j) >= yBinStarts, 1, 'last');
                whichYBinEnd = find(yDat(j) < yBinEnds, 1, 'first');
                
                % if either is empty, yDat point exceeds y limits
                if (~isempty(whichYBinStart) && ~isempty(whichYBinEnd))
                    whichYBin = whichYBinStart;
                else
                    whichYBin = [];
                end
                
                % put data point in correct bin
                if (~isempty(whichXBin) && ~isempty(whichYBin))
                    % sum in value, will later use for averaging
                    heatmapMat(whichYBin, whichXBin, i) = ...
                        heatmapMat(whichYBin, whichXBin, i) + zDat(j);
                    % update counter, will use for averaging and filtering
                    countsMat(whichYBin, whichXBin, i) = ...
                        countsMat(whichYBin, whichXBin, i) + 1;
                end
                
            % if plotting not moving data, if it is valid not moving point
            elseif (plotNotMove && ~isnan(xDatNM(j)) && ...
                ~isnan(yDatNM(j)) && ~isnan(zDatNM(j)))
            
                % find index of bin, going from both directions of start
                %  and end of bin
                whichXBinStart = find(xDatNM(j) >= xBinStarts, 1, 'last');
                whichXBinEnd = find(xDatNM(j) < xBinEnds, 1, 'first');
            
                % if either is empty, xDat point exceeds x limits
                if (~isempty(whichXBinStart) && ~isempty(whichXBinEnd))
                    whichXBin = whichXBinStart;
                else
                    whichXBin = [];
                end
                
                % find index of bin, going from both directions of start
                %  and end of bin
                whichYBinStart = find(yDatNM(j) >= yBinStarts, 1, 'last');
                whichYBinEnd = find(yDatNM(j) < yBinEnds, 1, 'first');
                
                % if either is empty, yDat point exceeds y limits
                if (~isempty(whichYBinStart) && ~isempty(whichYBinEnd))
                    whichYBin = whichYBinStart;
                else
                    whichYBin = [];
                end
                
                % put data point in correct bin
                if (~isempty(whichXBin) && ~isempty(whichYBin))
                    % sum in value, will later use for averaging
                    heatmapMat(whichYBin, whichXBin, i) = ...
                        heatmapMat(whichYBin, whichXBin, i) + zDatNM(j);
                    % update counter, will use for averaging and filtering
                    countsMat(whichYBin, whichXBin, i) = ...
                        countsMat(whichYBin, whichXBin, i) + 1;
                end
            end 
        end
    end
    
    % get mean value for each heatmap bin
    % NaN for every bin that has fewer than min number of data points
    %  allowed
    countsMat(countsMat < minNumVals) = nan;
    heatmapMat = heatmapMat ./ countsMat;
    
    % zScale
    colorScale = redblue(colorRes);
    % shift so only 1 middle value is white
    colorScale(2:(colorRes/2 + 1), :) = colorScale(1:(colorRes/2),:);
    % index 1 corresponds to color for NaN
    colorScale(1,:) = nanVal;
    minColorInd = 2; % since ind 1 is NaN color, min ind for a color is 2
    
    % max difference from value set to white
    maxAmp = max(abs(zScale - colorbarWhite));
    % use maxAmp to determine scale factor between zScale and colorScale:
    % maxAmp corresponds to 1/2 of colorScale; c per z
    zcScFctr = ((colorRes - 1)/2) / maxAmp;
    
    % generate heat maps in colorbar indicies for plotting
    if ~(samePlot) % separate plots for each fly
    
        % conversion b/w z and color
        heatmapPlotMat = zcScFctr .* (heatmapMat - colorbarWhite) + ...
            (colorRes/2 + 1);

    else % one heat map averaged across flies to plot
        heatmapMean = NaN(size(heatmapMat,1), size(heatmapMat,2));
        % loop over all bins
        for i = 1:size(heatmapMean,1)
            for j = 1:size(heatmapMean,2)
                % compute mean across flies, exluding flies without enough
                %  data for that bin
                binVals = heatmapMat(i, j, :);
                tempMean = mean(binVals(~isnan(binVals)));
                if ~isnan(tempMean) % mean of [] is NaN
                    heatmapMean(i, j) = tempMean;
                end
            end
        end
        
        % convert to colorbar indicies for plotting
        heatmapPlotMat = zcScFctr .* (heatmapMean - colorbarWhite) + ...
            (colorRes/2 + 1);
    end
    
    % values that exceed zScale boundaries in either direction are set
    %  to min/max color values
    heatmapPlotMat(heatmapPlotMat < minColorInd) = minColorInd;
    heatmapPlotMat(heatmapPlotMat > colorRes) = colorRes;

    % NaNs in heatmap set to 1, to plot as color for bins without
    %  enough data
    heatmapPlotMat(isnan(heatmapPlotMat)) = 1;
    
    % scale factors for colorbar
    % exclude 1 from showing on colorbar
    colorbarLims = [minColorInd colorRes]; 
%     % where ticks are, in indicies to colorbar
%     tickLocs = minColorInd:((colorRes-minColorInd)/(numTicks-1)):colorRes;
    % tick labels, in z axis units
%     tickLabels = ((tickLocs - (colorRes/2 + 1)) / zcScFctr) + colorbarWhite;
    
    tickLabels = zScale(1):((zScale(2)-zScale(1))/(numTicks - 1)):zScale(2);
    tickLocs = zcScFctr .* (tickLabels - colorbarWhite) + ...
            (colorRes/2 + 1);
    
    % plot heatmap(s)
    for i = 1:size(heatmapPlotMat,3)
        f(i) = figure;
        colormap(colorScale);
        
        imgHandle = imagesc(xBinMids, yBinMids, heatmapPlotMat(:,:,i));
        ax = gca;
        ax.YDir = 'normal';
        imgHandle.CDataMapping = 'direct';
        
        % axis labels
        xlabel(sprintf('%s (%s)', xDataName, xUnits));
        ylabel(sprintf('%s (%s)', yDataName, yUnits));
        
        
        colorbarHandle = colorbar('LimitsMode', 'manual', 'Limits',...
            colorbarLims, 'TicksMode', 'manual', 'Ticks', tickLocs, ...
            'TickLabelsMode', 'manual', 'TickLabels', tickLabels);
%         colorbarHandle = colorbar('LimitsMode', 'manual', 'Limits',...
%             colorbarLims);
        colorbarHandle.Label.String = sprintf('%s (%s)', zDataName, zUnits);
        
        % plot title
        if (samePlot)
            ttlStr = sprintf('%s %s vs. %s and %s (n = %d)', ttl, ...
                zDataName, xDataName, yDataName, numFlies);
        else
            ttlStr = sprintf('%s %s vs. %s and %s (fly ID %d)', ttl, ...
                zDataName, xDataName, yDataName, condPairData(i).flyID);
        end
        
        title(ttlStr); 
    end
    
end
% heatmapMoveCondData.m
%
% Function to generate heat map of movement conditioned data generated by
%  moveCondPairData(). Similar to scatterMoveCondData() but as heat map,
%  plots the value of the dependent variable z against two independent
%  variables, x and y. Each value in heatmap is a mean of the values that
%  contributed to it.
% Specify x, y, and z data by field name. Can run any combination of
%  fictrac and imaging data, though some aren't very meaningful.
% Plots either multiple flies on the same heatmap or individual flies each
%  as own figure.
% Plots either only data during moving bouts or all data.
% Can specify temporal offset between z data and x,y data. 
% Specify number of bins as well as min and max values for all variables.
%
% INPUTS:
%   condPairData - array of structs, output of moveCondPairData()
%   xDataName - string specifying name of data to put on x-axis;
%       independent variable 1
%   yDataName - string specifying name of data to put on y-axis;
%       independent variable 2
%   zDataName - string specifying name of data to represent as color on
%       heat map; dependent variable; if this is 'counts', heat map is
%       instead count of number of values in each bin (relates x and y data)
%   xScale - 3 element vector of [xmin, xmax, xNumBins]
%   yScale - 3 element vector of [ymin, ymax, yNumBins]
%   zScale - z axis limits, as 2 element vector
%   minNumVals - minimum number of values that need to be in a bin for it
%       to be plotted in heat map, per fly
%   offset - offset between zData and x/y Data, positive values are zData
%       before x/yData, negative values are zData before x/yData; in units
%       of samples
%   samePlot - binary for whether to put all flies on same plot (1) or to
%       generate a separate figure for each fly (0)
%   plotNotMove - binary for whether to plot not moving data points; (1)
%       for yes, (0) for no; nothing distinguishes moving from not moving
%       points in heat map if (1)
%   degPerMM - if not empty, will convert any fictrac variables using mm to
%       deg, using this conversion factor
%   ttl - plot title
%
% OUTPUTS:
%   f - handle to figure(s)
%   heatmapMat - matrix of heat map values (not color indicies) that went
%       into plots
%   countsMat - number of values per bin
%
% CREATED: 9/13/19 - HHY
%
% UPDATED: 9/19/19 - HHY
%

function [f, heatmapMat, countsMat] = heatmapMoveCondData(condPairData,...
    xDataName, yDataName, zDataName, xScale, yScale, zScale, minNumVals,...
    offset, samePlot, plotNotMove, degPerMM, ttl)

    colorRes = 256; % number of different colors in heatmap, must be even
    colorbarWhite = 0; % using redblue colorbar, what value is white
    nanVal = [0.5 0.5 0.5]; % value for bins without enough data
    numTicks = 11; % number of ticks for colorbar
    
    % fictrac behavioral variables
    behVars = {'fwdVel', 'slideVel', 'yawAngVel', 'yawAngSpd', ...
        'totAngSpd'};
    % imaging variables
    imgVars = {'left', 'right', 'sum', 'diff'};
    
    % number of flies
    numFlies = length(condPairData);
    
    % preallocate matrix that will become heat map, dimension 3 is number
    %  of flies, rows = y, col = x
    heatmapMat = zeros(yScale(3), xScale(3), numFlies);
    % preallocate matrix that counts number of samples that go into each
    %  bin
    countsMat = zeros(size(heatmapMat));
    
    % (xmax-xmin)/xNumBins
    xBinWidth = (xScale(2) - xScale(1)) / xScale(3);
    % start values of x bins
    xBinStarts = xScale(1):xBinWidth:(xScale(2) - xBinWidth);
    % end values of x bins
    xBinEnds = (xScale(1) + xBinWidth):xBinWidth:xScale(2);
    % midpoints of x bins (for plotting)
    xBinMids = (xBinStarts + xBinEnds) / 2;
    
    % same for y bins
    yBinWidth = (yScale(2) - yScale(1)) / yScale(3);
    yBinStarts = yScale(1):yBinWidth:(yScale(2) - yBinWidth);
    yBinEnds = (yScale(1) + yBinWidth):yBinWidth:yScale(2);
    yBinMids = (yBinStarts + yBinEnds) / 2;
    
    % loop through all flies
    for i = 1:numFlies
        % get x data, assumes xDataName is field of img or fictrac
        if (any(strcmpi(imgVars, xDataName)))
            xDat = condPairData(i).img.(xDataName);
            xDat(condPairData(i).moveLog) = nan;
            % not moving data
            xDatNM = condPairData(i).img.(xDataName);
            xDatNM(condPairData(i).notMoveLog) = nan;
            xUnits = 'dF/F';
        else
            xDat = condPairData(i).fictrac.move.(xDataName);
            xDatNM = condPairData(i).fictrac.notMove.(xDataName);
            % if the x data is in mm and the user desires a conversion
            %  to degrees
            if ~isempty(degPerMM) && ...
                    any(strcmpi(behVars(1:2), xDataName))
                xDat = xDat .* degPerMM;
                xDatNM = xDatNM .* degPerMM;
                xUnits = 'deg/s';
            elseif any(strcmpi(behVars(3:end), xDataName))
                xUnits = 'deg/s';
            else
                xUnits = 'mm/s';
            end
        end
        % get y data, assumes yDataName is field of img or fictrac
        if (any(strcmpi(imgVars, yDataName)))
            yDat = condPairData(i).img.(yDataName);
            yDat(condPairData(i).moveLog) = nan;
            % not moving data
            yDatNM = condPairData(i).img.(yDataName);
            yDatNM(condPairData(i).notMoveLog) = nan;
            yUnits = 'dF/F';
        else
            yDat = condPairData(i).fictrac.move.(yDataName);
            yDatNM = condPairData(i).fictrac.notMove.(yDataName);
            % if the y data is in mm and the user desires a conversion
            %  to degrees
            if ~isempty(degPerMM) && ...
                    any(strcmpi(behVars(1:2), yDataName))
                yDat = yDat .* degPerMM;
                yDatNM = yDatNM .* degPerMM;
                yUnits = 'deg/s';
            elseif any(strcmpi(behVars(3:end), yDataName))
                yUnits = 'deg/s';
            else
                yUnits = 'mm/s';
            end
        end
        zIsCount = 0; % boolean for whether z-data is count
        % get z data, assumes zDataName is field of img or fictrac
        if (any(strcmpi(imgVars, zDataName)))
            zDat = condPairData(i).img.(zDataName);
            zDat(condPairData(i).moveLog) = nan;
            % not moving data
            zDatNM = condPairData(i).img.(zDataName);
            zDatNM(condPairData(i).notMoveLog) = nan;
            zUnits = 'dF/F';
        elseif (any(strcmpi(behVars, zDataName)))
            zDat = condPairData(i).fictrac.move.(zDataName);
            zDatNM = condPairData(i).fictrac.notMove.(zDataName);
            % if the z data is in mm and the user desires a conversion
            %  to degrees
            if ~isempty(degPerMM) && ...
                    any(strcmpi(behVars(1:2), zDataName))
                zDat = zDat .* degPerMM;
                zDatNM = zDatNM .* degPerMM;
                zUnits = 'deg/s';
            elseif any(strcmpi(behVars(3:end), zDataName))
                zUnits = 'deg/s';
            else
                zUnits = 'mm/s';
            end
        elseif (strcmpi('counts', zDataName))
            zDat = ones(size(condPairData(i).moveLog));
            zDatNM = zDat;
            zDat(condPairData(i).moveLog) = nan;
            zDatNM(condPairData(i).notMoveLog) = nan;
            zIsCount = 1;
        end
        
        % introduce offset to data
        xDat = circshift(xDat, offset);
        yDat = circshift(yDat, offset);
        if (plotNotMove)
            xDatNM = circshift(xDatNM, offset);
            yDatNM = circshift(yDatNM, offset);
        end
        % delete appropriate number of elements from xDat, yDat, zDat, so
        %  wrapped elements aren't used
        if (offset < 0) % negative offsets, remove from end
            xDat = xDat(1:(end + offset));
            yDat = yDat(1:(end + offset));
            zDat = zDat(1:(end + offset));
            if (plotNotMove)
                xDatNM = xDatNM(1:(end + offset));
                yDatNM = yDatNM(1:(end + offset));
                zDatNM = zDatNM(1:(end + offset));
            end
        elseif (offset > 0) % positive offsets, remove from front
            xDat = xDat((offset + 1):end);
            yDat = yDat((offset + 1):end);
            zDat = zDat((offset + 1):end);
            if (plotNotMove)
                xDatNM = xDatNM((offset + 1):end);
                yDatNM = yDatNM((offset + 1):end);
                zDatNM = zDatNM((offset + 1):end);
            end
        end
        
        % loop through all data points, put each one in appropriate bin
        for j = 1:length(xDat)
            % point has all valid values (not NaN)
            if (~isnan(xDat(j)) && ~isnan(yDat(j)) && ~isnan(zDat(j)))
                % find index of bin, going from both directions of start
                %  and end of bin
                whichXBinStart = find(xDat(j) >= xBinStarts, 1, 'last');
                whichXBinEnd = find(xDat(j) < xBinEnds, 1, 'first');
            
                % if either is empty, xDat point exceeds x limits
                if (~isempty(whichXBinStart) && ~isempty(whichXBinEnd))
                    whichXBin = whichXBinStart;
                else
                    whichXBin = [];
                end
                
                % find index of bin, going from both directions of start
                %  and end of bin
                whichYBinStart = find(yDat(j) >= yBinStarts, 1, 'last');
                whichYBinEnd = find(yDat(j) < yBinEnds, 1, 'first');
                
                % if either is empty, yDat point exceeds y limits
                if (~isempty(whichYBinStart) && ~isempty(whichYBinEnd))
                    whichYBin = whichYBinStart;
                else
                    whichYBin = [];
                end
                
                % put data point in correct bin
                if (~isempty(whichXBin) && ~isempty(whichYBin))
                    % sum in value, will later use for averaging
                    heatmapMat(whichYBin, whichXBin, i) = ...
                        heatmapMat(whichYBin, whichXBin, i) + zDat(j);
                    % update counter, will use for averaging and filtering
                    countsMat(whichYBin, whichXBin, i) = ...
                        countsMat(whichYBin, whichXBin, i) + 1;
                end
                
            % if plotting not moving data, if it is valid not moving point
            elseif (plotNotMove && ~isnan(xDatNM(j)) && ...
                ~isnan(yDatNM(j)) && ~isnan(zDatNM(j)))
            
                % find index of bin, going from both directions of start
                %  and end of bin
                whichXBinStart = find(xDatNM(j) >= xBinStarts, 1, 'last');
                whichXBinEnd = find(xDatNM(j) < xBinEnds, 1, 'first');
            
                % if either is empty, xDat point exceeds x limits
                if (~isempty(whichXBinStart) && ~isempty(whichXBinEnd))
                    whichXBin = whichXBinStart;
                else
                    whichXBin = [];
                end
                
                % find index of bin, going from both directions of start
                %  and end of bin
                whichYBinStart = find(yDatNM(j) >= yBinStarts, 1, 'last');
                whichYBinEnd = find(yDatNM(j) < yBinEnds, 1, 'first');
                
                % if either is empty, yDat point exceeds y limits
                if (~isempty(whichYBinStart) && ~isempty(whichYBinEnd))
                    whichYBin = whichYBinStart;
                else
                    whichYBin = [];
                end
                
                % put data point in correct bin
                if (~isempty(whichXBin) && ~isempty(whichYBin))
                    % sum in value, will later use for averaging
                    heatmapMat(whichYBin, whichXBin, i) = ...
                        heatmapMat(whichYBin, whichXBin, i) + zDatNM(j);
                    % update counter, will use for averaging and filtering
                    countsMat(whichYBin, whichXBin, i) = ...
                        countsMat(whichYBin, whichXBin, i) + 1;
                end
            end 
        end
    end
    

    % only when data to be plotted is not counts; get heat map values to
    %  plot, scaling
    if ~zIsCount
        % get mean value for each heatmap bin
        % NaN for every bin that has fewer than min number of data points
        %  allowed
        countsMat(countsMat < minNumVals) = nan;
        heatmapMat = heatmapMat ./ countsMat;
    
        % zScale
        colorScale = redblue(colorRes);
        % shift so only 1 middle value is white
        colorScale(2:(colorRes/2 + 1), :) = colorScale(1:(colorRes/2),:);
        % index 1 corresponds to color for NaN
        colorScale(1,:) = nanVal;
        minColorInd = 2; % since ind 1 is NaN color, min ind for a color is 2

        % max difference from value set to white
        maxAmp = max(abs(zScale - colorbarWhite));
        % use maxAmp to determine scale factor between zScale and colorScale:
        % maxAmp corresponds to 1/2 of colorScale; c per z
        zcScFctr = ((colorRes - minColorInd)/2) / maxAmp;

        % generate heat maps in colorbar indicies for plotting
        if ~(samePlot) % separate plots for each fly

            % conversion b/w z and color
            heatmapPlotMat = zcScFctr .* (heatmapMat - colorbarWhite) + ...
                (colorRes/2 + 1);

        else % one heat map averaged across flies to plot
            heatmapMean = NaN(size(heatmapMat,1), size(heatmapMat,2));
            % loop over all bins
            for i = 1:size(heatmapMean,1)
                for j = 1:size(heatmapMean,2)
                    % compute mean across flies, exluding flies without
                    %  enough data for that bin
                    binVals = heatmapMat(i, j, :);
                    tempMean = mean(binVals(~isnan(binVals)));
                    if ~isnan(tempMean) % mean of [] is NaN
                        heatmapMean(i, j) = tempMean;
                    end
                end
            end

            % convert to colorbar indicies for plotting
            heatmapPlotMat = zcScFctr .* (heatmapMean - colorbarWhite) + ...
                (colorRes/2 + 1);
        end

        % values that exceed zScale boundaries in either direction are set
        %  to min/max color values
        heatmapPlotMat(heatmapPlotMat < minColorInd) = minColorInd;
        heatmapPlotMat(heatmapPlotMat > colorRes) = colorRes;

        % NaNs in heatmap set to 1, to plot as color for bins without
        %  enough data
        heatmapPlotMat(isnan(heatmapPlotMat)) = 1;

        % scale factors for colorbar
        % exclude 1 from showing on colorbar
        colorbarLims = [minColorInd colorRes]; 

        % where ticks are, on zScale; will become tick labels
        tickLabels = zScale(1):((zScale(2)-zScale(1))/(numTicks - 1)):zScale(2);
        % where ticks are, in indicies
        tickLocs = zcScFctr .* (tickLabels - colorbarWhite) + ...
            (colorRes/2 + 1);
    
    % plot counts; set up color scale
    else
        % zScale
        colorScale = parula(colorRes);
        minColorInd = 1; % shift corresponding to 1 vs 0 indexing
        
        zcScFctr = (colorRes - minColorInd) / (zScale(2)-zScale(1));
        
        % separate counts plot for each fly
        if ~(samePlot)
            % conversion b/w z and color
            heatmapPlotMat = zcScFctr .* (countsMat - zScale(1)) + ...
                minColorInd;
        else % one heat map, of summed counts across all flies
            heatmapSum = sum(countsMat,3);

            % convert to colorbar indicies for plotting
            heatmapPlotMat = zcScFctr .* (heatmapSum - zScale(1)) + ...
                minColorInd;
        end
        
        % scale factors for colorbar
        colorbarLims = [minColorInd colorRes]; 

        % where ticks are, on zScale; will become tick labels
        tickLabels = zScale(1):((zScale(2)-zScale(1))/(numTicks - 1)):zScale(2);
        % where ticks are, in indicies
        tickLocs = zcScFctr .* (tickLabels - zScale(1)) + minColorInd;
    end
    
    % plot heatmap(s)
    for i = 1:size(heatmapPlotMat,3)
        f(i) = figure;
        colormap(colorScale);
        
        imgHandle = imagesc(xBinMids, yBinMids, heatmapPlotMat(:,:,i));
        % invert axes so smaller values on y axis toward bottom
        ax = gca;
        ax.YDir = 'normal';
        % this property needs to be set here and not as option in imagesc
        %  initial call (doesn't work there)
        imgHandle.CDataMapping = 'direct';
        
        % axis labels
        xlabel(sprintf('%s (%s)', xDataName, xUnits));
        ylabel(sprintf('%s (%s)', yDataName, yUnits));
        
        % colorbar, scaled and labeled appropriately for z-axis data
        colorbarHandle = colorbar('LimitsMode', 'manual', 'Limits',...
            colorbarLims, 'TicksMode', 'manual', 'Ticks', tickLocs, ...
            'TickLabelsMode', 'manual', 'TickLabels', tickLabels);
        if ~zIsCount
            colorbarHandle.Label.String = sprintf('%s (%s)', ...
                zDataName, zUnits);
        else
            colorbarHandle.Label.String = zDataName;
        end
        
        % plot title
        if ~zIsCount
            if (samePlot)
                ttlStr = sprintf('%s %s vs. %s and %s (n = %d)', ttl, ...
                    zDataName, xDataName, yDataName, numFlies);
            else
                ttlStr = sprintf('%s %s vs. %s and %s (fly ID %d)', ttl, ...
                    zDataName, xDataName, yDataName, condPairData(i).flyID);
            end
        else
            if (samePlot)
                ttlStr = sprintf('%s %s %s vs. %s (n = %d)', ttl, ...
                    zDataName, yDataName, xDataName, numFlies);
            else
                ttlStr = sprintf('%s %s %s vs. %s (fly ID %d)', ttl, ...
                    zDataName, yDataName, xDataName, condPairData(i).flyID);
            end
        end
        
        title(ttlStr); 
    end
    
end